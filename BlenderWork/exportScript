import bpy
import Blender
import copy
from Blender import *



outFile = open("out.txt", "w")



def	compareVertexIndexPair(a, b):
	if( a[1] < b[1]):
		return -1
	elif( a[1] == b[1] ):
		return 0
	else:
		return 1


def meshProcess(object):
	print "---- meshProcess start ----"
	print object.getData(name_only=1)

	outFile.write( "type Mesh\n" )
	outFile.write( "name %s\n" % object.getData(name_only=1) )
	
	mesh = object.getData(mesh=1)
	print "vertex count %d" % len(mesh.verts)
	print "face count %d" % len(mesh.faces)
	
	#
	#mesh data
	#
	newUVvertexList = [];
	solidFaceList = [];
	
	indexList  = [];
	normalList = [];
	
	#base smooth vertex to new indexes
	baseVertex = {}
	
	#
	#mesh prepare, generate vertex and new indexes
	#genereate vertexes for solid faces
	#
	currentIndex = 0
	
	for face in mesh.faces:
		if( face.smooth ):
			for vert in face.verts:
				vertIndex = face.verts.index(vert)
				
				if( face.verts[ vertIndex ] not in baseVertex.keys() ):
					baseVertex[ face.verts[ vertIndex ] ] = currentIndex
					currentIndex = currentIndex + 1	
	
		else:
			solidFaceList.append( face )
			
	
	#for smooth: genereate vertex if found save vertex with different uv coordinates		
			
	#vertex to found uv data, to found uv repeat
	vertexUVdict = {}
	
	#face to dict with [ face vertex index, new vertex index ]
	faceVertexReplaceDict = {}
	
	baseVertexCount = len( baseVertex )
			
	for face in mesh.faces:
		if( face.smooth ):
			for vert in face.verts:
				vertIndex = face.verts.index(vert)
				
				if( vert not in vertexUVdict.keys() ):
					vertexUVdict[ vert ] = face.uv[ vertIndex ]
					
				elif vertexUVdict[ vert ].x != face.uv[ vertIndex ].x or vertexUVdict[ vert ].y != face.uv[ vertIndex ].y:

					if face in faceVertexReplaceDict.keys():
						faceVertexReplaceDict[ face ][vertIndex] = baseVertexCount + len( newUVvertexList )
					else:
						faceVertexReplaceDict[ face ] = {}
						faceVertexReplaceDict[ face ][vertIndex] = baseVertexCount + len( newUVvertexList )
						
					newUVvertexList.append( vert )
		
	
	#
	#vertex export
	#
	baseVertexPair = baseVertex.items()
	baseVertexPair.sort(compareVertexIndexPair)
	
	print "vertexUVdict len=", len( vertexUVdict )
	print "newUVvertexList len = ", len(newUVvertexList)
	print "solicFaceList len = ", len(solidFaceList)
	
	outFile.write( "vertexCount %d\n" % (len(baseVertex.keys()) + len( newUVvertexList ) + len(solidFaceList)*3) )
	for pair in baseVertexPair:
		outFile.write( "vert %f %f %f\n" % ( pair[0].co.x, pair[0].co.y, pair[0].co.z) )
	
	for vert in newUVvertexList:
		outFile.write( "vert %f %f %f\n" % ( vert.co.x, vert.co.y, vert.co.z) )
	
	for face in solidFaceList:
		outFile.write( "vert %f %f %f\n" % (face.verts[0].co.x, face.verts[0].co.y, face.verts[0].co.z) )
		outFile.write( "vert %f %f %f\n" % (face.verts[1].co.x, face.verts[1].co.y, face.verts[1].co.z) )
		outFile.write( "vert %f %f %f\n" % (face.verts[2].co.x, face.verts[2].co.y, face.verts[2].co.z) )
		
	
	#delimeter it need to reload loader state
	outFile.write( "\n" )
	
	#
	#normal export
	#
	for pair in baseVertexPair:
		outFile.write( "norm %f %f %f\n" % ( pair[0].no.x, pair[0].no.y, pair[0].no.z) )
		
	for vert in newUVvertexList:
		outFile.write( "norm %f %f %f\n" % ( vert.no.x, vert.no.y, vert.no.z) )
		
	for face in solidFaceList:
		outFile.write( "norm %f %f %f\n" % (face.no.x, face.no.y, face.no.z) )
		outFile.write( "norm %f %f %f\n" % (face.no.x, face.no.y, face.no.z) )
		outFile.write( "norm %f %f %f\n" % (face.no.x, face.no.y, face.no.z) )
		
	#
	#uv export
	#
	if( mesh.faceUV ):
		print "export face UV"
		
		#delimeter need to reload loader state
		outFile.write( "\n" )
		
		for pair in baseVertexPair:
			pair[0].sel = 1
			
		for face in mesh.faces:
			for vert in face.verts:
				if( vert in baseVertex.keys() and vert.sel == 1 ):
					outFile.write( "uv %f %f\n" % ( face.uv[ face.verts.index(vert) ][0], face.uv[ face.verts.index(vert) ][1] ) )
					vert.sel = 0
					
		for face in mesh.faces:
			if face in faceVertexReplaceDict.keys():
				for vert in face.verts:
					if face.verts.index(vert) in faceVertexReplaceDict[face].keys():
						print faceVertexReplaceDict[face][ face.verts.index(vert) ]
						#outFile.write( "uv 1 1\n" )
						outFile.write( "uv %f %f\n" % ( face.uv[ face.verts.index(vert) ][0], face.uv[ face.verts.index(vert) ][1] ) )
					
		for face in solidFaceList:
			for uv in face.uv:
				outFile.write( "uv %f %f\n" % ( uv[0], uv[1] ) )
				
	#uv to vertex index
#	uvDict = {}
#	
#	if( mesh.faceUV ):
#		print "export vertex UV"
#		
#		
#		
#		#delimeter it need to reload loader state
#		outFile.write( "\n" )
#		
#		for pair in baseVertexPair:
#			pair[0].sel = 1
#	
#		for face in mesh.faces:
#			for vert in face.verts:
#				if( vert.sel == 1 ):
#					vert.sel = 0
#					uvDict[ baseVertex[vert] ] = face.uv[ face.verts.index(vert) ]
#				else:
#					if uvDict[ baseVertex[vert] ][0] == face.uv[ face.verts.index(vert) ][1] and uvDict[ baseVertex[vert] ][1] == face.uv[ face.verts.index(vert) ][0]:
#						print "BANG !!!"
#	
#		for i in range(0,len(uvDict.keys())):
#			outFile.write( "uv %f %f\n" % ( uvDict[i][0], uvDict[i][1] ) )
#		
#		for face in solidFaceList:
#			for uv in face.uv:
#				outFile.write( "uv %f %f\n" % ( uv[0], uv[1] ) )
#				
#		for pair in baseVertexPair:
#			pair[0].sel = 0

#	if( mesh.vertexUV ):
#		print "export vertex UV"
#		
#		#delimeter it need to reload loader state
#		outFile.write( "\n" )
#		
#		for pair in baseVertexPair:
#			outFile.write( "uv %f %f\n" % ( pair[0].uvco.x, pair[0].uvco.y) )
	
			
	#
	#vertexGroupIndex export
	#
	for groupName in mesh.getVertGroupNames():
		vertIndexes = mesh.getVertsFromGroup(groupName)
		outFile.write( "vertexGroup %s\n" % groupName )
		
		for vertIndex in vertIndexes:
			mesh.verts[vertIndex].sel = 1
			
		faceCount = 0
		for face in mesh.faces:
			if( face.verts[0].sel == 1 and face.verts[1].sel == 1 and face.verts[2].sel == 1 ):
				faceCount += 1
				
				
		outFile.write( "vertexIndexCount %d\n" % faceCount )
		solidIndexOffset = len( mesh.verts )
		
		for face in mesh.faces:
			if( face.verts[0].sel == 1 and face.verts[1].sel == 1 and face.verts[2].sel == 1 ):
				if( face.smooth ):
					
					#check
					if face in faceVertexReplaceDict.keys():
						outFile.write( "face")
						
						for vert in face.verts:	
							if face.verts.index( vert ) in faceVertexReplaceDict[face].keys():
								outFile.write( " %d" % faceVertexReplaceDict[face][ face.verts.index(vert) ] )
							else:
								outFile.write( " %d" %  baseVertex[ face.verts[ face.verts.index(vert) ] ]  )

						outFile.write( "\n" )

					else:
						outFile.write( "face %d %d %d\n" % ( baseVertex[ face.verts[0] ], baseVertex[ face.verts[1] ], baseVertex[ face.verts[2] ] ) )					
				
				else:
					
					solidVertexIndex = len(baseVertex) + len(newUVvertexList) + solidFaceList.index(face)*3
					outFile.write( "face %d %d %d\n" % (solidVertexIndex, solidVertexIndex+1, solidVertexIndex+2) )					
					

		for vertIndex in vertIndexes:
			mesh.verts[vertIndex].sel = 0
				
		outFile.write( "end\n" )
		
		
	print "smooth mode =", mesh.mode & Mesh.Modes["AUTOSMOOTH"]
	
	#printa
	#print "mesh.faces"	
	#for face in mesh.faces:
	#	print
	#	print face, "no = ", face.no
	#	
	#	if( mesh.faceUV ):
	#		print "have uv"
	#		
	#		for uv in face.uv:
	#			print uv
	#			
	#	else:
	#		print "not have uv"
	#	
	#	print "\tface.verts"
	#	for vert in face.verts:
	#		print "\tindex = ", vert.index, "no = ", vert.no
			
	print "materials"
	for material in mesh.materials:
		print material
		print "alpha = ", material.alpha
		print "diffuse = ", material.rgbCol
		print "specular = ", material.specCol
		
		print
		print "Textures"
		for texture in material.getTextures():
			if(texture != None):
				print texture
				print texture.tex.image.filename
		
		
	outFile.write( "end\n" )
	
	print "---- meshProcess end ----"


def cameraProcess(object):
	print "---- cameraProcess start ----"
	print object.getData(name_only=1)
	print "---- cameraProcess end ----"
	
	
def lampProcess(object):
	print "---- lampProcess start ----"
	print object.getData(name_only=1)
	print "---- lampProcess end ----"


print "---- start ----"
print list(bpy.data.objects)

for obj in bpy.data.objects:
	mesh = obj.getData(mesh=1)
	print type(mesh)

	if( type(mesh) == Types.MeshType ):
		meshProcess(obj)
		
	elif( type(mesh) == Types.CameraType ):
		cameraProcess(obj)
		
	elif( type(mesh) == Types.LampType ):
		lampProcess(obj)
		
outFile.close()
print "---- end ----"